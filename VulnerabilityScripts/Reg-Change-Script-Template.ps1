<#
.SYNOPSIS
This script is a template for making changes to the registry.
To use it, simply copy the "$RegChange" array, and input your data.
Each array must have a unique name, so I recommend the following naming convention:
Add a number to the end of each RegChange variable name, followed by some descriptive words, EG: $script:RegChange1SMBWorkstation, $script:RegChange2SMBServer, etc.

.DESCRIPTION
Below are some notes on each variable and how to input data into them correctly

* REGPATH
The registry path in which the registry value will be placed. The supported hives are:

HKCR (HKEY_CLASSES_ROOT) / HKCU (HKEY_CURRENT_USER) / HKLM (HKEY_LOCAL_MACHINE) / HKU (HKEY_USERS) / HKCC (HKEY_CURRENT_CONFIG) 

* REG ITEM NAME
The reg item name is the name of the value you're adding, for example "EnableSecuritySignature"

* VALUE OF REG ITEM
Value of reg item is the data against that value, so to enable security signatures, you would set this to 1

* PROPERTY TYPE
Property type has to match one of the datatypes in the documenation for "reg add", any variation from these will stop the script from running.
"REG_SZ" and "REG_DWORD" are the only two datatypes you need 99% of the time, the others are rarely needed.


.EXAMPLE

function ChangeList {
    $script:RegChange = @(
        "REG PATH",
        "REG ITEM NAME",
        "VALUE OF REG ITEM",
        "PROPERTY TYPE"
    )
    
    $script:RegChange1SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
        "RequireSecuritySignature",
        "1",
        "REG_DWORD"
    )

    $script:RegChange2SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManWorkstation\Parameters",
        "EnableSecuritySignature",
        "1",
        "REG_DWORD"
    )

    $script:RegChange3SMBSigning = @(
        "Computer\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters",
        "RequireSecuritySignature",
        "1",
        "REG_DWORD"
    )
}

.NOTES
This script does not support remote registries or manually loaded hives.

It will make directories it cannot find but only to 2 levels
If it cannot find HKLM:\x\y\z for exmaple, it wont rebuild, however it cannot find HKLM:\x\y it will make the directories x and y
This feature can be turned via the $RebuildMode variable ($false/$true) below
#>

################################################################################################################################################


function ChangeList {
    $script:RegChange1 = @(
        "REG PATH",
        "REG ITEM NAME",
        "VALUE OF REG ITEM",
        "PROPERTY TYPE"
    )
}

############
# Controls #
############

$BackupPath = "C:\Source\Registry-Backups\"
# Path for the registry backup files

$RebuildMode = $true
# Rebuild broken paths

# Edit this to give your script a title that appears when executed
function Menu {
    Write-Host "*******************************"
    Write-Host "******** SCRIPT TITLE *********"
    Write-Host "*******************************"
    Write-Host "***** Available Commands: *****"
    Write-Host "*********** Commit ************"
    Write-Host "*********** Revert ************"
    Write-Host "*******************************"
}

###################################
# !!! SCRIPT CODE STARTS HERE !!! #
###################################

Clear-Host

<#[array]$ChangeList = Get-Variable | Where {$_.Name -like "RegChange?*"}
if ($changeList.count -ge 1) {
    Return "Please restart the machine as old changes are still present in the enviroment."
} ELSE { #>
    ChangeList
#}

Menu

[array]$ChangeList = Get-Variable | Where {$_.Name -like "RegChange?*"}


function DataValidation {

    # Double checking there's a backslash at the end of the backup path so we can join reliably regardless if the user put it there or not
    If (!$BackupPath.EndsWith("\")) {
        $BackupPath = $BackupPath + "\"
    }
    # Preparing the data to be validated by the subsequent switch statements by corrected an easy to make error
    if ($RegPath.StartsWith('Computer\')) {
        $script:RegPath = $RegPath.Replace("Computer\","")
    }
    # If the user has entered the wrong format, correct it
    switch -Wildcard ($RegPath) {
        "HKEY_CLASSES_ROOT*" {  $script:RegPath = $RegPath.Replace("HKEY_CLASSES_ROOT","HKCR:") }
        "HKEY_CURRENT_USER*" {  $script:RegPath = $RegPath.Replace("HKEY_CURRENT_USER","HKCU:")   }
        "HKEY_LOCAL_MACHINE*" {  $script:RegPath = $RegPath.Replace("HKEY_LOCAL_MACHINE","HKLM:")   }
        "HKEY_USERS*" {  $script:RegPath = $RegPath.Replace("HKEY_USERS","HKU:") }
        "HKEY_CURRENT_CONFIG*" {  $script:RegPath = $RegPath.Replace("HKEY_CURRENT_CONFIG","HKCC:")  }
        ELSE {  }
    }
    # Now that we've corrected any easy mistakes, make sure the format is correct
    switch -Wildcard ($RegPath) {
        "HKCR:\*" {}
        "HKCU:\*" {}
        "HKLM:\*" {}
        "HKU:\*" {}
        "HKCC:\*" {}
        else { Return "ERROR - Unrecognised data - The hive of the RegPath does not match any supported hives. Please double check the RegPath variable" }
    }
    # We know any datatypes outside of these will not be supported, so make sure it matches them
    switch ($DataType) {
        "REG_SZ" {
            # Setting the value to a string as string registry entries require strings (obviously...)
            $Value = [string]$Value
            
        }
        "REG_MULTI_SZ" {}
        "REG_DWORD" {
            # Setting the value to an int as DWords only accept integers
            $Value = [int]$Value
            
        }
        "REG_BINARY" {}
        "REG_DWORD_BIG_ENDIAN" {}
        "REG_DWORD_LITTLE_ENDIAN" {}
        "REG_LINK" {}
        "REG_FULL_RESOURCE_DESCRIPTOR" {}
        "REG_EXPAND_SZ" {}
        ELSE { Return "ERROR - Unrecognised data type in $ChangeName! Please double check the data type variable (Fourth variable down)." }
    }
    if ((Get-ItemPropertyValue -Path $RegPath -Name $RegEntry -ErrorAction SilentlyContinue) -eq $Value) {
        Return "ERROR - $ChangeName is already the desired value! Skipping..."
    }
    Return "Data Valid"
}
function PathCheck {

    $path = $RegPath
    $PathType = "Container"
    $test = Test-Path -Path $path -PathType $PathType

if (!$test) {
    [array]$SplitPath = $path.split("\")
    $SectionCount = ($SplitPath | Measure-Object).Count
    $x = 0
    DO {
        $PathType = "Container"
        $x++
        $y = $SectionCount - $x
        [string]$z = ($SplitPath[0..$y] -join '\')
        $FindFault = Test-Path -Path $z -PathType $PathType
        if ($y -eq 1) { Return "The registry path for $ChangeName is broken at the root! Please double check the RegPath variable (first variable)" }
    } Until($FindFault)

    # If path is only out by two sections at the end of the path, then we rebuild using the reverse of the logic above

    $x--
    if (($FindFault) -and ($x -le 2) -and ($RebuildMode)) {
		DO {
            $Script:BackupRegPath = ($SplitPath[0..$y] -join '\')
			$y = $SectionCount - $x
			[string]$z = ($SplitPath[0..($y - 1)] -join '\')
			New-Item -Path $z -Name $Splitpath[$y] -ItemType Directory
		    $x--
		} Until (($X -eq 0))
	}
            if ((Test-Path -Path $Path -Pathtype $PathType) -and ($FindFault)) {

                Return "Path found. Keys were added to the directory as they could not be found."
            } ELSE { Return "ERROR - Tried to rebuild path for $ChangeName but still cannot find the path."
        } ELSE {
            Return "ERROR - The registry path for $ChangeName is broken. The path breaks at $z"
            }
    } ELSE {
        $Script:BackupRegPath = $RegPath
        Return "Path found. The path was found without any intervention needed."; }
}

function BackupReg {

    if (Test-Path $BackupPath -PathType Container) {
        $BackupExist = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf
        if ($BackupExist) {
            return "Successfully found a backup of $RegPath"
        }
    } ELSE {
        New-Item -Path "C:\Source\" -name "Registry-Backups" -ItemType Directory -Force
    }
    reg save ($BackupRegPath).Replace(":","") ($BackupPath + $BackupFile) /f
    $BackupCreated = Test-Path -Path ($BackupPath + $BackupFile) -PathType Leaf

    if ($BackupCreated) {
        return "Successfully created a backup of $RegPath"
    } ELSE {
        return "Failed to create a backup of the registry key: $RegPath"
    }
}

function CommitChange {


    reg add ($RegPath.Replace(":","")) /v $RegEntry /t $DataType /d $Value /f
    $NewValue = Get-ItemPropertyValue -Path $RegPath -Name $RegEntry

    if ($NewValue -eq $Value) {
        Return "Successfully changed the value of $RegEntry in $RegPath"
    }
    ELSE {
        Return "$ChangeName is not the expected value after changing! The value is $NewValue"
    }
}

###########################################
# Commands that will be given to the user #
###########################################

function Commit {
    Clear-Host
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = $ChangeName + ".reg"
        Write-Host "************** $ChangeName **************"
        Write-Host "Starting"
        Write-Host "Validating Data..."
        $ValidData = DataValidation
        if ($ValidData -notlike "ERROR - *") {
            Write-Host "Validating Path..."
            $PathValid = PathCheck
            if ($PathValid -like "Path found*") {
                Write-Host "Backing up registy..."
                $Backup = BackupReg
                if ($Backup -like "Successfully*") {
                    Write-Host "Committing change..."
                    CommitChange
                }
                else { Write-host "No backup for $ChangeName, skipping change..." }
            }
            ELSE { Write-Output "Cannot find path specified in $ChangeName, skipping..." }                
        }  
        ELSE { $ValidData }
    } 
    Read-Host "All changes done! Press enter to return to the menu."
    Menu
}
function Revert {
    Clear-Host
    Foreach ($change in $ChangeList) {
        $script:RegPath = $Change.value[0]
        $script:RegEntry = $Change.value[1]
        $script:Value = $Change.value[2]
        $script:DataType = $Change.value[3]
        $script:ChangeName = $Change.Name
        $script:BackupFile = $ChangeName + ".reg"
        Write-Host "************** $ChangeName **************"
        DataValidation
        $RestoreOperation = Reg Restore ($RegPath).Replace(":","") ($BackupPath + $BackupFile)
        if ($RestoreOperation -match "The operation completed successfully.") {
            Write-Host "Successful restored the registry for path: $RegPath"
        } ELSE { Write-Host "Failed to restore the registry for the path: $RegPath" }
    }
    Read-Host "All changes done! Press enter to return to the menu."
    Menu
}
